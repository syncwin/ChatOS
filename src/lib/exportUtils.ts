import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { decodeHtmlEntities } from '@/lib/utils';

export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  provider?: string;
  model?: string;
  created_at?: string;
  isStreaming?: boolean;
}

export interface ConversationPair {
  user: Message | null;
  assistant: Message | null;
}

export interface Profile {
  username?: string;
  nickname?: string;
}

/**
 * Converts markdown text to HTML for PDF export
 */
export const markdownToHtml = (markdown: string): string => {
  if (!markdown) return '';
  
  let html = markdown
    // Convert headers
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    // Convert bold and italic
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    // Convert code blocks
    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    // Convert links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
    // Convert lists
    .replace(/^\* (.*)$/gim, '<li>$1</li>')
    .replace(/^- (.*)$/gim, '<li>$1</li>')
    .replace(/^\d+\. (.*)$/gim, '<li>$1</li>')
    // Convert line breaks and paragraphs
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>');
  
  // Wrap lists in ul/ol tags
  html = html.replace(/(<li>.*<\/li>)/gs, (match) => {
    if (match.includes('<li>')) {
      return `<ul>${match}</ul>`;
    }
    return match;
  });
  
  // Wrap content in paragraphs if not already wrapped
  if (html && !html.startsWith('<')) {
    html = `<p>${html}</p>`;
  }
  
  return html;
};

/**
 * Gets conversation pairs from messages array
 */
export const getConversationPairs = (
  messages: Message[],
  currentMessage: Message
): ConversationPair[] => {
  const conversationMessages = messages.length > 0 ? messages : [currentMessage];
  const currentIndex = conversationMessages.findIndex(msg => msg.id === currentMessage.id);
  const pairs: ConversationPair[] = [];
  
  // Single message export - only export the specific message pair
  if (currentMessage.role === 'assistant') {
    // Find the preceding user message
    let userMsg = null;
    for (let i = currentIndex - 1; i >= 0; i--) {
      if (conversationMessages[i].role === 'user') {
        userMsg = conversationMessages[i];
        break;
      }
    }
    pairs.push({ user: userMsg, assistant: currentMessage });
  } else if (currentMessage.role === 'user') {
    // Find the following assistant message
    let aiMsg = null;
    for (let i = currentIndex + 1; i < conversationMessages.length; i++) {
      if (conversationMessages[i].role === 'assistant') {
        aiMsg = conversationMessages[i];
        break;
      }
    }
    pairs.push({ user: currentMessage, assistant: aiMsg });
  }
  
  return pairs;
};

/**
 * Exports conversation as Markdown file
 */
export const exportAsMarkdown = (
  conversationPairs: ConversationPair[],
  profile: Profile | null
): void => {
  const userName = profile?.username || profile?.nickname || 'User';
  
  let markdownContent = `# ChatOS - Single Message Export\n\n`;
  markdownContent += `**Export Date:** ${new Date().toLocaleString()}\n\n`;
  markdownContent += `**Export Type:** Single Message Pair\n\n`;
  markdownContent += `---\n\n`;
  
  conversationPairs.forEach((pair, index) => {
    if (pair.user) {
      markdownContent += `### ðŸ‘¤ ${userName}\n\n`;
      markdownContent += `${decodeHtmlEntities(pair.user.content)}\n\n`;
    }
    
    if (pair.assistant) {
      markdownContent += `### ðŸ¤– ChatOS\n\n`;
      markdownContent += `${decodeHtmlEntities(pair.assistant.content)}\n\n`;
      
      if (pair.assistant.provider || pair.assistant.model) {
        markdownContent += `**Model Info:**\n`;
        if (pair.assistant.provider) markdownContent += `- Provider: ${pair.assistant.provider}\n`;
        if (pair.assistant.model) markdownContent += `- Model: ${pair.assistant.model}\n`;
        markdownContent += `\n`;
      }
    }
    
    if (index < conversationPairs.length - 1) {
      markdownContent += `---\n\n`;
    }
  });
  
  markdownContent += `\n---\n\n*Generated by ChatOS*`;
  
  // Create and download markdown file
  const blob = new Blob([markdownContent], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `chatOS-single-message-${new Date().toISOString().split('T')[0]}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

/**
 * Creates PDF content HTML structure
 */
export const createPdfContent = (
  conversationPairs: ConversationPair[],
  profile: Profile | null
): string => {
  const userName = profile?.username || profile?.nickname || 'User';
  
  let pdfContent = `
    <header style="margin-bottom: 40px; padding-bottom: 30px; background: linear-gradient(to bottom, transparent 0%, #f8f9fa 100%);">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
        <div style="display: flex; align-items: center;">
          <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #3f00ff 0%, #8b5cf6 50%, #ff8000 100%); border-radius: 12px; margin-right: 20px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 24px; box-shadow: 0 4px 12px rgba(63, 0, 255, 0.3);">C</div>
          <div>
            <h1 style="margin: 0; color: #3f00ff; font-size: 32px; font-weight: 700; letter-spacing: -0.5px;">ChatOS</h1>
            <p style="margin: 0; color: #64748b; font-size: 14px; font-weight: 500;">Single Message Export</p>
          </div>
        </div>
        <div style="text-align: right; color: #64748b; font-size: 12px;">
          <p style="margin: 0;"><strong>Export Date:</strong> ${new Date().toLocaleString()}</p>
          <p style="margin: 0;"><strong>Export Type:</strong> Single Message Pair</p>
        </div>
      </div>
    </header>
    
    <main>
  `;
  
  // Add conversation pairs
  conversationPairs.forEach((pair, index) => {
    pdfContent += `<section style="margin-bottom: 40px;">`;
    
    // User Input
    if (pair.user) {
      const userHtmlContent = markdownToHtml(decodeHtmlEntities(pair.user.content));
      pdfContent += `
        <article style="background: #f8f9fa; border-radius: 16px; padding: 24px; margin-bottom: 20px;">
          <header style="display: flex; align-items: center; margin-bottom: 16px;">
            <span style="background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); color: white; padding: 6px 16px; border-radius: 20px; font-size: 11px; font-weight: 600; text-transform: uppercase; margin-right: 12px; box-shadow: 0 2px 4px rgba(14, 165, 233, 0.3);">ðŸ‘¤ Question</span>
            <span style="color: #0369a1; font-weight: 600; font-size: 14px;">${userName}</span>
          </header>
          <div style="font-size: 14px; line-height: 1.7; color: #1e293b;">
            ${userHtmlContent}
          </div>
        </article>
      `;
    }
    
    // AI Response
    if (pair.assistant) {
      const assistantHtmlContent = markdownToHtml(decodeHtmlEntities(pair.assistant.content));
      pdfContent += `
        <article style="background: #f1f5f9; border-radius: 16px; padding: 24px; margin-bottom: 20px;">
          <header style="display: flex; align-items: center; margin-bottom: 16px;">
            <span style="background: linear-gradient(135deg, #64748b 0%, #475569 100%); color: white; padding: 6px 16px; border-radius: 20px; font-size: 11px; font-weight: 600; text-transform: uppercase; margin-right: 12px; box-shadow: 0 2px 4px rgba(100, 116, 139, 0.3);">ðŸ¤– Answer</span>
            <span style="color: #475569; font-weight: 600; font-size: 14px;">ChatOS</span>
          </header>
          <div style="font-size: 14px; line-height: 1.7; color: #1e293b;">
            ${assistantHtmlContent}
          </div>
      `;
      
      // Add model information if available
      if (pair.assistant.provider || pair.assistant.model) {
        pdfContent += `
          <footer style="margin-top: 16px; padding-top: 16px; background: linear-gradient(to bottom, transparent 0%, #e2e8f0 100%); font-size: 12px; color: #64748b;">
            <div style="display: flex; gap: 20px;">
              ${pair.assistant.provider ? `<span><strong>Provider:</strong> ${pair.assistant.provider}</span>` : ''}
              ${pair.assistant.model ? `<span><strong>Model:</strong> ${pair.assistant.model}</span>` : ''}
            </div>
          </footer>
        `;
      }
      
      pdfContent += `</article>`;
    }
    
    pdfContent += `</section>`;
    
    if (index < conversationPairs.length - 1) {
      pdfContent += `<div style="page-break-before: always;"></div>`;
    }
  });
  
  pdfContent += `
    </main>
    
    <footer style="margin-top: 60px; padding-top: 30px; background: linear-gradient(to bottom, transparent 0%, #f8f9fa 100%); text-align: center; color: #64748b; font-size: 12px;">
      <p style="margin: 0; font-weight: 600;">Generated by ChatOS</p>
      <p style="margin: 0;">Advanced AI Chat Platform</p>
    </footer>
  `;
  
  return pdfContent;
};

/**
 * Exports conversation as PDF file
 */
export const exportAsPdf = async (
  conversationPairs: ConversationPair[],
  profile: Profile | null
): Promise<void> => {
  if (conversationPairs.length === 0) {
    throw new Error('No conversation content to export');
  }
  
  // Create a temporary container for PDF content
  const pdfContainer = document.createElement('div');
  pdfContainer.style.position = 'fixed';
  pdfContainer.style.top = '-9999px';
  pdfContainer.style.left = '0';
  pdfContainer.style.width = '800px';
  pdfContainer.style.backgroundColor = '#ffffff';
  pdfContainer.style.padding = '40px';
  pdfContainer.style.fontFamily = 'system-ui, -apple-system, sans-serif';
  pdfContainer.style.fontSize = '14px';
  pdfContainer.style.lineHeight = '1.6';
  pdfContainer.style.color = '#333333';
  
  const pdfContent = createPdfContent(conversationPairs, profile);
  pdfContainer.innerHTML = pdfContent;
  
  document.body.appendChild(pdfContainer);
  
  try {
    // Convert to canvas with high quality
    const canvas = await html2canvas(pdfContainer, {
      scale: 2,
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff',
      width: 800,
      windowWidth: 800,
      scrollX: 0,
      scrollY: 0
    });
    
    // Create PDF
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });
    
    const imgWidth = 210; // A4 width in mm
    const pageHeight = 297; // A4 height in mm
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    let heightLeft = imgHeight;
    let position = 0;
    
    // Add first page
    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;
    
    // Add additional pages if needed
    while (heightLeft >= 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }
    
    // Save the PDF
    pdf.save(`chatOS-single-message-${new Date().toISOString().split('T')[0]}.pdf`);
  } finally {
    // Clean up
    document.body.removeChild(pdfContainer);
  }
};